// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: faiss_index.proto

package faiss_gogofaster

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ItemInfo struct {
	ItemId    string  `protobuf:"bytes,1,opt,name=ItemId,proto3" json:"ItemId,omitempty"`
	Score     float32 `protobuf:"fixed32,2,opt,name=Score,proto3" json:"Score,omitempty"`
	Embedding float32 `protobuf:"fixed32,3,opt,name=Embedding,proto3" json:"Embedding,omitempty"`
}

func (m *ItemInfo) Reset()         { *m = ItemInfo{} }
func (m *ItemInfo) String() string { return proto.CompactTextString(m) }
func (*ItemInfo) ProtoMessage()    {}
func (*ItemInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{0}
}
func (m *ItemInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ItemInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ItemInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ItemInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ItemInfo.Merge(m, src)
}
func (m *ItemInfo) XXX_Size() int {
	return m.Size()
}
func (m *ItemInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ItemInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ItemInfo proto.InternalMessageInfo

func (m *ItemInfo) GetItemId() string {
	if m != nil {
		return m.ItemId
	}
	return ""
}

func (m *ItemInfo) GetScore() float32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *ItemInfo) GetEmbedding() float32 {
	if m != nil {
		return m.Embedding
	}
	return 0
}

type UserVectorInfo struct {
	UserId     string    `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	UserVector []float32 `protobuf:"fixed32,2,rep,packed,name=UserVector,proto3" json:"UserVector,omitempty"`
}

func (m *UserVectorInfo) Reset()         { *m = UserVectorInfo{} }
func (m *UserVectorInfo) String() string { return proto.CompactTextString(m) }
func (*UserVectorInfo) ProtoMessage()    {}
func (*UserVectorInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{1}
}
func (m *UserVectorInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserVectorInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserVectorInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserVectorInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserVectorInfo.Merge(m, src)
}
func (m *UserVectorInfo) XXX_Size() int {
	return m.Size()
}
func (m *UserVectorInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UserVectorInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UserVectorInfo proto.InternalMessageInfo

func (m *UserVectorInfo) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *UserVectorInfo) GetUserVector() []float32 {
	if m != nil {
		return m.UserVector
	}
	return nil
}

type RecallRequest struct {
	IndexName       string          `protobuf:"bytes,1,opt,name=IndexName,proto3" json:"IndexName,omitempty"`
	UserVectorInfo_ *UserVectorInfo `protobuf:"bytes,2,opt,name=UserVectorInfo_,json=UserVectorInfo,proto3" json:"UserVectorInfo_,omitempty"`
	RecallNum       int32           `protobuf:"varint,3,opt,name=RecallNum,proto3" json:"RecallNum,omitempty"`
}

func (m *RecallRequest) Reset()         { *m = RecallRequest{} }
func (m *RecallRequest) String() string { return proto.CompactTextString(m) }
func (*RecallRequest) ProtoMessage()    {}
func (*RecallRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{2}
}
func (m *RecallRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecallRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecallRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecallRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecallRequest.Merge(m, src)
}
func (m *RecallRequest) XXX_Size() int {
	return m.Size()
}
func (m *RecallRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RecallRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RecallRequest proto.InternalMessageInfo

func (m *RecallRequest) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *RecallRequest) GetUserVectorInfo_() *UserVectorInfo {
	if m != nil {
		return m.UserVectorInfo_
	}
	return nil
}

func (m *RecallRequest) GetRecallNum() int32 {
	if m != nil {
		return m.RecallNum
	}
	return 0
}

type RecallResponse struct {
	UserId    string      `protobuf:"bytes,1,opt,name=UserId,proto3" json:"UserId,omitempty"`
	ItemInfo_ []*ItemInfo `protobuf:"bytes,2,rep,name=ItemInfo_,json=ItemInfo,proto3" json:"ItemInfo_,omitempty"`
}

func (m *RecallResponse) Reset()         { *m = RecallResponse{} }
func (m *RecallResponse) String() string { return proto.CompactTextString(m) }
func (*RecallResponse) ProtoMessage()    {}
func (*RecallResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{3}
}
func (m *RecallResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecallResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecallResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecallResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecallResponse.Merge(m, src)
}
func (m *RecallResponse) XXX_Size() int {
	return m.Size()
}
func (m *RecallResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RecallResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RecallResponse proto.InternalMessageInfo

func (m *RecallResponse) GetUserId() string {
	if m != nil {
		return m.UserId
	}
	return ""
}

func (m *RecallResponse) GetItemInfo_() []*ItemInfo {
	if m != nil {
		return m.ItemInfo_
	}
	return nil
}

type IndexInfo struct {
	IndexName        string `protobuf:"bytes,1,opt,name=IndexName,proto3" json:"IndexName,omitempty"`
	IndexMd5         string `protobuf:"bytes,2,opt,name=IndexMd5,proto3" json:"IndexMd5,omitempty"`
	IndexType        string `protobuf:"bytes,3,opt,name=IndexType,proto3" json:"IndexType,omitempty"`
	IndexLoadTime    string `protobuf:"bytes,4,opt,name=IndexLoadTime,proto3" json:"IndexLoadTime,omitempty"`
	IndexDim         int32  `protobuf:"varint,5,opt,name=IndexDim,proto3" json:"IndexDim,omitempty"`
	IndexVectorsSize int32  `protobuf:"varint,6,opt,name=IndexVectorsSize,proto3" json:"IndexVectorsSize,omitempty"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}
func (*IndexInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{4}
}
func (m *IndexInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IndexInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IndexInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IndexInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IndexInfo.Merge(m, src)
}
func (m *IndexInfo) XXX_Size() int {
	return m.Size()
}
func (m *IndexInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_IndexInfo.DiscardUnknown(m)
}

var xxx_messageInfo_IndexInfo proto.InternalMessageInfo

func (m *IndexInfo) GetIndexName() string {
	if m != nil {
		return m.IndexName
	}
	return ""
}

func (m *IndexInfo) GetIndexMd5() string {
	if m != nil {
		return m.IndexMd5
	}
	return ""
}

func (m *IndexInfo) GetIndexType() string {
	if m != nil {
		return m.IndexType
	}
	return ""
}

func (m *IndexInfo) GetIndexLoadTime() string {
	if m != nil {
		return m.IndexLoadTime
	}
	return ""
}

func (m *IndexInfo) GetIndexDim() int32 {
	if m != nil {
		return m.IndexDim
	}
	return 0
}

func (m *IndexInfo) GetIndexVectorsSize() int32 {
	if m != nil {
		return m.IndexVectorsSize
	}
	return 0
}

type GetIndexInfoRequest struct {
}

func (m *GetIndexInfoRequest) Reset()         { *m = GetIndexInfoRequest{} }
func (m *GetIndexInfoRequest) String() string { return proto.CompactTextString(m) }
func (*GetIndexInfoRequest) ProtoMessage()    {}
func (*GetIndexInfoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{5}
}
func (m *GetIndexInfoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexInfoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexInfoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexInfoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexInfoRequest.Merge(m, src)
}
func (m *GetIndexInfoRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexInfoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexInfoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexInfoRequest proto.InternalMessageInfo

type GetIndexInfoResponse struct {
	IndexInfo_ []*IndexInfo `protobuf:"bytes,1,rep,name=IndexInfo_,json=IndexInfo,proto3" json:"IndexInfo_,omitempty"`
}

func (m *GetIndexInfoResponse) Reset()         { *m = GetIndexInfoResponse{} }
func (m *GetIndexInfoResponse) String() string { return proto.CompactTextString(m) }
func (*GetIndexInfoResponse) ProtoMessage()    {}
func (*GetIndexInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_29f09d8b963a7b04, []int{6}
}
func (m *GetIndexInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetIndexInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetIndexInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetIndexInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetIndexInfoResponse.Merge(m, src)
}
func (m *GetIndexInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetIndexInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetIndexInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetIndexInfoResponse proto.InternalMessageInfo

func (m *GetIndexInfoResponse) GetIndexInfo_() []*IndexInfo {
	if m != nil {
		return m.IndexInfo_
	}
	return nil
}

func init() {
	proto.RegisterType((*ItemInfo)(nil), "ItemInfo")
	proto.RegisterType((*UserVectorInfo)(nil), "UserVectorInfo")
	proto.RegisterType((*RecallRequest)(nil), "RecallRequest")
	proto.RegisterType((*RecallResponse)(nil), "RecallResponse")
	proto.RegisterType((*IndexInfo)(nil), "IndexInfo")
	proto.RegisterType((*GetIndexInfoRequest)(nil), "GetIndexInfoRequest")
	proto.RegisterType((*GetIndexInfoResponse)(nil), "GetIndexInfoResponse")
}

func init() { proto.RegisterFile("faiss_index.proto", fileDescriptor_29f09d8b963a7b04) }

var fileDescriptor_29f09d8b963a7b04 = []byte{
	// 453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x53, 0xcf, 0x6b, 0x13, 0x41,
	0x14, 0xce, 0xa4, 0x26, 0x74, 0x5f, 0x6d, 0x56, 0xc7, 0x54, 0x87, 0x50, 0x96, 0xb0, 0x88, 0xa4,
	0x82, 0x23, 0x44, 0x04, 0xa1, 0x27, 0x45, 0xa9, 0x01, 0x2d, 0x32, 0xa9, 0x3d, 0x78, 0x59, 0xb6,
	0xbb, 0x2f, 0x61, 0xa1, 0xbb, 0xb3, 0xee, 0x6c, 0x45, 0xbd, 0xf7, 0xee, 0x9f, 0xe5, 0xb1, 0xde,
	0x3c, 0x4a, 0xf2, 0x8f, 0xc8, 0xce, 0xfe, 0x98, 0x6e, 0xad, 0xbd, 0x84, 0xf9, 0xbe, 0x79, 0xf3,
	0xde, 0xf7, 0x7d, 0x2f, 0x0b, 0x77, 0x17, 0x7e, 0xa4, 0x94, 0x17, 0x25, 0x21, 0x7e, 0xe5, 0x69,
	0x26, 0x73, 0xe9, 0x1e, 0xc3, 0xe6, 0x2c, 0xc7, 0x78, 0x96, 0x2c, 0x24, 0xbd, 0x0f, 0x7d, 0x7d,
	0x0e, 0x19, 0x19, 0x93, 0x89, 0x25, 0x2a, 0x44, 0x87, 0xd0, 0x9b, 0x07, 0x32, 0x43, 0xd6, 0x1d,
	0x93, 0x49, 0x57, 0x94, 0x80, 0xee, 0x82, 0xf5, 0x26, 0x3e, 0xc1, 0x30, 0x8c, 0x92, 0x25, 0xdb,
	0xd0, 0x37, 0x86, 0x70, 0xdf, 0xc2, 0xe0, 0xa3, 0xc2, 0xec, 0x18, 0x83, 0x5c, 0x66, 0x75, 0xf7,
	0x82, 0x31, 0xdd, 0x4b, 0x44, 0x1d, 0x00, 0x53, 0xc9, 0xba, 0xe3, 0x8d, 0x49, 0x57, 0x5c, 0x62,
	0xdc, 0x73, 0x02, 0xdb, 0x02, 0x03, 0xff, 0xf4, 0x54, 0xe0, 0xe7, 0x33, 0x54, 0x79, 0x31, 0x79,
	0x56, 0x58, 0x38, 0xf4, 0x63, 0xac, 0x9a, 0x19, 0x82, 0xbe, 0x00, 0xbb, 0x3d, 0xd9, 0xd3, 0xba,
	0xb7, 0xa6, 0x36, 0x6f, 0xf3, 0xe2, 0xaa, 0xc2, 0x5d, 0xb0, 0xca, 0x41, 0x87, 0x67, 0xb1, 0x76,
	0xd4, 0x13, 0x86, 0x70, 0x3f, 0xc0, 0xa0, 0x96, 0xa1, 0x52, 0x99, 0x28, 0xfc, 0xaf, 0xa3, 0x47,
	0x60, 0xd5, 0x99, 0x7a, 0xda, 0xd0, 0xd6, 0xd4, 0xe2, 0x35, 0x23, 0x9a, 0xbc, 0xdd, 0x5f, 0xa4,
	0x32, 0x52, 0x4f, 0xbf, 0xc1, 0xd5, 0x08, 0x36, 0x35, 0x78, 0x1f, 0x3e, 0xd7, 0x76, 0x2c, 0xd1,
	0xe0, 0xe6, 0xe5, 0xd1, 0xb7, 0x14, 0xb5, 0xee, 0xfa, 0x65, 0x41, 0xd0, 0x87, 0xb0, 0xad, 0xc1,
	0x3b, 0xe9, 0x87, 0x47, 0x51, 0x8c, 0xec, 0x96, 0xae, 0x68, 0x93, 0x4d, 0xff, 0xd7, 0x51, 0xcc,
	0x7a, 0xda, 0x7a, 0x83, 0xe9, 0x63, 0xb8, 0xa3, 0xcf, 0x65, 0x54, 0x6a, 0x1e, 0x7d, 0x47, 0xd6,
	0xd7, 0x35, 0xff, 0xf0, 0xee, 0x0e, 0xdc, 0x3b, 0xc0, 0xbc, 0x71, 0x55, 0xad, 0xcc, 0x7d, 0x09,
	0xc3, 0x36, 0x5d, 0x45, 0xb8, 0x07, 0xd0, 0x90, 0x1e, 0x23, 0x3a, 0x2b, 0xe0, 0xa6, 0xce, 0xe4,
	0x33, 0x3d, 0x27, 0xf0, 0xe0, 0x20, 0x4b, 0x83, 0x72, 0x09, 0x73, 0xcc, 0xbe, 0x60, 0x56, 0xfc,
	0x46, 0x01, 0xd2, 0x27, 0x00, 0xe6, 0x8a, 0x0e, 0x78, 0xeb, 0xff, 0x32, 0xb2, 0xf9, 0x95, 0xc5,
	0xed, 0xc3, 0xed, 0xcb, 0x6a, 0xe8, 0x90, 0x5f, 0xa3, 0x79, 0xb4, 0xc3, 0xaf, 0x93, 0xfc, 0x6a,
	0xef, 0xe7, 0xca, 0x21, 0x17, 0x2b, 0x87, 0xfc, 0x59, 0x39, 0xe4, 0xc7, 0xda, 0xe9, 0x5c, 0xac,
	0x9d, 0xce, 0xef, 0xb5, 0xd3, 0xf9, 0x64, 0xf3, 0xa7, 0xfb, 0xf9, 0x42, 0x15, 0x9a, 0x92, 0xa5,
	0xb7, 0x94, 0x27, 0x7d, 0xfd, 0x8d, 0x3d, 0xfb, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x54, 0x5b, 0x3c,
	0xf4, 0x78, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GrpcRecallServerServiceClient is the client API for GrpcRecallServerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GrpcRecallServerServiceClient interface {
	GrpcRecall(ctx context.Context, in *RecallRequest, opts ...grpc.CallOption) (*RecallResponse, error)
	GetIndexInfo(ctx context.Context, in *GetIndexInfoRequest, opts ...grpc.CallOption) (*GetIndexInfoResponse, error)
}

type grpcRecallServerServiceClient struct {
	cc *grpc.ClientConn
}

func NewGrpcRecallServerServiceClient(cc *grpc.ClientConn) GrpcRecallServerServiceClient {
	return &grpcRecallServerServiceClient{cc}
}

func (c *grpcRecallServerServiceClient) GrpcRecall(ctx context.Context, in *RecallRequest, opts ...grpc.CallOption) (*RecallResponse, error) {
	out := new(RecallResponse)
	err := c.cc.Invoke(ctx, "/GrpcRecallServerService/GrpcRecall", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *grpcRecallServerServiceClient) GetIndexInfo(ctx context.Context, in *GetIndexInfoRequest, opts ...grpc.CallOption) (*GetIndexInfoResponse, error) {
	out := new(GetIndexInfoResponse)
	err := c.cc.Invoke(ctx, "/GrpcRecallServerService/GetIndexInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GrpcRecallServerServiceServer is the server API for GrpcRecallServerService service.
type GrpcRecallServerServiceServer interface {
	GrpcRecall(context.Context, *RecallRequest) (*RecallResponse, error)
	GetIndexInfo(context.Context, *GetIndexInfoRequest) (*GetIndexInfoResponse, error)
}

// UnimplementedGrpcRecallServerServiceServer can be embedded to have forward compatible implementations.
type UnimplementedGrpcRecallServerServiceServer struct {
}

func (*UnimplementedGrpcRecallServerServiceServer) GrpcRecall(ctx context.Context, req *RecallRequest) (*RecallResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GrpcRecall not implemented")
}
func (*UnimplementedGrpcRecallServerServiceServer) GetIndexInfo(ctx context.Context, req *GetIndexInfoRequest) (*GetIndexInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIndexInfo not implemented")
}

func RegisterGrpcRecallServerServiceServer(s *grpc.Server, srv GrpcRecallServerServiceServer) {
	s.RegisterService(&_GrpcRecallServerService_serviceDesc, srv)
}

func _GrpcRecallServerService_GrpcRecall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcRecallServerServiceServer).GrpcRecall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GrpcRecallServerService/GrpcRecall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcRecallServerServiceServer).GrpcRecall(ctx, req.(*RecallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GrpcRecallServerService_GetIndexInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIndexInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GrpcRecallServerServiceServer).GetIndexInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/GrpcRecallServerService/GetIndexInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GrpcRecallServerServiceServer).GetIndexInfo(ctx, req.(*GetIndexInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GrpcRecallServerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "GrpcRecallServerService",
	HandlerType: (*GrpcRecallServerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GrpcRecall",
			Handler:    _GrpcRecallServerService_GrpcRecall_Handler,
		},
		{
			MethodName: "GetIndexInfo",
			Handler:    _GrpcRecallServerService_GetIndexInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "faiss_index.proto",
}

func (m *ItemInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ItemInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ItemInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Embedding != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Embedding))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Score != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Score))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.ItemId) > 0 {
		i -= len(m.ItemId)
		copy(dAtA[i:], m.ItemId)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.ItemId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserVectorInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserVectorInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserVectorInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserVector) > 0 {
		for iNdEx := len(m.UserVector) - 1; iNdEx >= 0; iNdEx-- {
			f1 := math.Float32bits(float32(m.UserVector[iNdEx]))
			i -= 4
			encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(f1))
		}
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.UserVector)*4))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecallRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecallRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecallRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecallNum != 0 {
		i = encodeVarintFaissIndex(dAtA, i, uint64(m.RecallNum))
		i--
		dAtA[i] = 0x18
	}
	if m.UserVectorInfo_ != nil {
		{
			size, err := m.UserVectorInfo_.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFaissIndex(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RecallResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecallResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecallResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ItemInfo_) > 0 {
		for iNdEx := len(m.ItemInfo_) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ItemInfo_[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFaissIndex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.UserId) > 0 {
		i -= len(m.UserId)
		copy(dAtA[i:], m.UserId)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.UserId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IndexInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IndexInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IndexInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IndexVectorsSize != 0 {
		i = encodeVarintFaissIndex(dAtA, i, uint64(m.IndexVectorsSize))
		i--
		dAtA[i] = 0x30
	}
	if m.IndexDim != 0 {
		i = encodeVarintFaissIndex(dAtA, i, uint64(m.IndexDim))
		i--
		dAtA[i] = 0x28
	}
	if len(m.IndexLoadTime) > 0 {
		i -= len(m.IndexLoadTime)
		copy(dAtA[i:], m.IndexLoadTime)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.IndexLoadTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IndexType) > 0 {
		i -= len(m.IndexType)
		copy(dAtA[i:], m.IndexType)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.IndexType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IndexMd5) > 0 {
		i -= len(m.IndexMd5)
		copy(dAtA[i:], m.IndexMd5)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.IndexMd5)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.IndexName) > 0 {
		i -= len(m.IndexName)
		copy(dAtA[i:], m.IndexName)
		i = encodeVarintFaissIndex(dAtA, i, uint64(len(m.IndexName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetIndexInfoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexInfoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexInfoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetIndexInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetIndexInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetIndexInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexInfo_) > 0 {
		for iNdEx := len(m.IndexInfo_) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IndexInfo_[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFaissIndex(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintFaissIndex(dAtA []byte, offset int, v uint64) int {
	offset -= sovFaissIndex(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ItemInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ItemId)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if m.Score != 0 {
		n += 5
	}
	if m.Embedding != 0 {
		n += 5
	}
	return n
}

func (m *UserVectorInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if len(m.UserVector) > 0 {
		n += 1 + sovFaissIndex(uint64(len(m.UserVector)*4)) + len(m.UserVector)*4
	}
	return n
}

func (m *RecallRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if m.UserVectorInfo_ != nil {
		l = m.UserVectorInfo_.Size()
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if m.RecallNum != 0 {
		n += 1 + sovFaissIndex(uint64(m.RecallNum))
	}
	return n
}

func (m *RecallResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserId)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if len(m.ItemInfo_) > 0 {
		for _, e := range m.ItemInfo_ {
			l = e.Size()
			n += 1 + l + sovFaissIndex(uint64(l))
		}
	}
	return n
}

func (m *IndexInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IndexName)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	l = len(m.IndexMd5)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	l = len(m.IndexType)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	l = len(m.IndexLoadTime)
	if l > 0 {
		n += 1 + l + sovFaissIndex(uint64(l))
	}
	if m.IndexDim != 0 {
		n += 1 + sovFaissIndex(uint64(m.IndexDim))
	}
	if m.IndexVectorsSize != 0 {
		n += 1 + sovFaissIndex(uint64(m.IndexVectorsSize))
	}
	return n
}

func (m *GetIndexInfoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetIndexInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IndexInfo_) > 0 {
		for _, e := range m.IndexInfo_ {
			l = e.Size()
			n += 1 + l + sovFaissIndex(uint64(l))
		}
	}
	return n
}

func sovFaissIndex(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFaissIndex(x uint64) (n int) {
	return sovFaissIndex(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ItemInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Score = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Embedding", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Embedding = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserVectorInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserVectorInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserVectorInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 5 {
				var v uint32
				if (iNdEx + 4) > l {
					return io.ErrUnexpectedEOF
				}
				v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
				iNdEx += 4
				v2 := float32(math.Float32frombits(v))
				m.UserVector = append(m.UserVector, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFaissIndex
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthFaissIndex
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthFaissIndex
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen / 4
				if elementCount != 0 && len(m.UserVector) == 0 {
					m.UserVector = make([]float32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					if (iNdEx + 4) > l {
						return io.ErrUnexpectedEOF
					}
					v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
					iNdEx += 4
					v2 := float32(math.Float32frombits(v))
					m.UserVector = append(m.UserVector, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVector", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecallRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecallRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecallRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVectorInfo_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserVectorInfo_ == nil {
				m.UserVectorInfo_ = &UserVectorInfo{}
			}
			if err := m.UserVectorInfo_.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecallNum", wireType)
			}
			m.RecallNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecallNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecallResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecallResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecallResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemInfo_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ItemInfo_ = append(m.ItemInfo_, &ItemInfo{})
			if err := m.ItemInfo_[len(m.ItemInfo_)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IndexInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IndexInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IndexInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexMd5", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexMd5 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexLoadTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexLoadTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexDim", wireType)
			}
			m.IndexDim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexDim |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexVectorsSize", wireType)
			}
			m.IndexVectorsSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexVectorsSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexInfoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexInfoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexInfoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetIndexInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetIndexInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetIndexInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexInfo_", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFaissIndex
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndexInfo_ = append(m.IndexInfo_, &IndexInfo{})
			if err := m.IndexInfo_[len(m.IndexInfo_)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFaissIndex(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFaissIndex
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFaissIndex(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFaissIndex
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFaissIndex
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFaissIndex
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFaissIndex
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFaissIndex
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFaissIndex        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFaissIndex          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFaissIndex = fmt.Errorf("proto: unexpected end of group")
)
